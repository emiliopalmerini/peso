<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Dashboard - Peso</title>
    <meta name="description" content="Track your weight and reach your goals">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Peso">
    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/static/icon-192.svg">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="stylesheet" href="/static/min.css">
    <script src="https://unpkg.com/htmx.org@1.9.12" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <header class="topbar">
        <div class="container topbar__inner">
            <a class="brand" href="/">Peso</a>
            <div class="topbar__user">
                <span class="topbar__user-name">{{.UserName}}</span>
                <a href="/logout" class="logout-link">Esci</a>
            </div>
        </div>
    </header>

    <main class="container page">
        <!-- Hero Stat -->
        <section class="page__section">
            <div class="stat-hero" id="stat-hero"
                 hx-get="/users/{{.UserID}}/stat-hero"
                 hx-trigger="load, weight-updated from:body"
                 hx-swap="innerHTML">
                <div class="skeleton" style="height: 80px; width: 200px; margin: 0 auto;"></div>
            </div>
        </section>

        <!-- Stat Pills -->
        <section class="page__section" style="margin-top: var(--space-4);">
            <div class="stat-pills" id="stat-pills"
                 hx-get="/users/{{.UserID}}/stat-pills"
                 hx-trigger="load, weight-updated from:body, goal-updated from:body"
                 hx-swap="innerHTML">
                <div class="stat-pill"><div class="skeleton" style="height: 48px; width: 80px;"></div></div>
            </div>
        </section>

        <!-- Goal panel -->
        <section class="page__section"><div id="panel"></div></section>

        <!-- Weight Chart -->
        <section class="page__section">
            <div class="chart">
                <div class="chart__head">
                    <div>
                        <span>Andamento</span>
                        <span id="goal-badge"
                              hx-get="/users/{{.UserID}}/goal-badge"
                              hx-trigger="load, weight-updated from:body, goal-updated from:body"></span>
                    </div>
                    <div class="period-chips" id="periodChips">
                        <button class="period-chip" data-period="week">1S</button>
                        <button class="period-chip" data-period="month">1M</button>
                        <button class="period-chip period-chip--active" data-period="3months">3M</button>
                        <button class="period-chip" data-period="6months">6M</button>
                        <button class="period-chip" data-period="year">1A</button>
                        <button class="period-chip" data-period="all">Tutto</button>
                    </div>
                </div>
                <div class="chart__body">
                    <canvas id="weightChart"></canvas>
                </div>
            </div>
        </section>

        <!-- Recent Weights -->
        <section class="page__section">
            <div class="section-header">
                <span class="section-header__title">Storico</span>
            </div>
            <div class="list" id="recent-weights"
                 hx-get="/users/{{.UserID}}/recent-weights"
                 hx-trigger="load, weight-updated from:body">
                <div class="row"><span class="text-muted">Caricamento...</span></div>
            </div>
        </section>

        <!-- Goal Summary -->
        <section class="page__section">
            <details>
                <summary>Obiettivo</summary>
                <div class="details-content" id="goal-summary"
                     hx-get="/users/{{.UserID}}/goal-summary"
                     hx-trigger="load, weight-updated from:body, goal-updated from:body">
                    <div class="text-muted">Caricamento...</div>
                </div>
            </details>
        </section>
    </main>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Pull to Refresh Indicator -->
    <div class="pull-indicator" id="pullIndicator">
        <svg class="pull-indicator__icon" viewBox="0 0 24 24">
            <path d="M23 4v6h-6M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
    </div>

    <script>
        // ============================================================
        // Color Scheme Detection
        // ============================================================
        const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');

        function getChartColors() {
            const isDark = darkModeQuery.matches;
            return {
                line: isDark ? 'rgb(242, 242, 242)' : 'rgb(17, 17, 17)',
                lineFill: isDark ? 'rgba(242, 242, 242, 0.05)' : 'rgba(17, 17, 17, 0.03)',
                scatter: isDark ? 'rgba(255, 255, 255, 0.25)' : 'rgba(0, 0, 0, 0.15)',
                goal: isDark ? 'rgb(102, 102, 102)' : 'rgb(200, 200, 200)',
                tooltip: isDark ? 'rgb(242, 242, 242)' : 'rgb(17, 17, 17)',
                tooltipText: isDark ? 'rgb(17, 17, 17)' : 'rgb(255, 255, 255)',
                grid: isDark ? 'rgba(255, 255, 255, 0.06)' : 'rgba(0, 0, 0, 0.04)',
                tick: isDark ? '#666666' : '#999999'
            };
        }

        function updateThemeColor() {
            const isDark = darkModeQuery.matches;
            const meta = document.querySelector('meta[name="theme-color"]');
            if (meta) {
                meta.content = isDark ? '#111111' : '#ffffff';
            }
        }

        darkModeQuery.addEventListener('change', () => {
            updateThemeColor();
            if (chart) renderChart();
        });
        updateThemeColor();

        // ============================================================
        // State
        // ============================================================
        let chart;
        let currentPeriod = '3months';
        let currentWeight = null;
        let saveTimeout = null;
        let isSaving = false;
        const userId = '{{.UserID}}';
        const ctx = document.getElementById('weightChart').getContext('2d');
        const goal = {{ if .ActiveGoal }}{{ if and .CreatedAt .StartWeight }} { targetWeight: {{.ActiveGoal.TargetWeight}}, targetDate: "{{.ActiveGoal.TargetDate}}", unit: "{{.ActiveGoal.Unit}}", createdAt: "{{.CreatedAt}}", startWeight: {{.StartWeight}} }{{ else }} { targetWeight: {{.ActiveGoal.TargetWeight}}, targetDate: "{{.ActiveGoal.TargetDate}}", unit: "{{.ActiveGoal.Unit}}" }{{ end }}{{ else }} null {{ end }};

        // ============================================================
        // Toast Notifications
        // ============================================================
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast toast--${type}`;
            toast.innerHTML = `<span class="toast__message">${message}</span>`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('toast--out');
                setTimeout(() => toast.remove(), 200);
            }, duration);
        }

        // ============================================================
        // Weight Adjustment (Plus/Minus)
        // ============================================================
        async function saveWeight(weight) {
            if (isSaving) return;
            isSaving = true;
            const hero = document.getElementById('stat-hero');
            hero.classList.add('stat-hero--saving');

            try {
                const formData = new FormData();
                formData.append('user_id', userId);
                formData.append('weight', weight.toFixed(1));
                const response = await fetch('/api/weights', {
                    method: 'POST',
                    body: formData
                });
                if (response.ok) {
                    showToast('Peso salvato', 'success');
                    document.body.dispatchEvent(new CustomEvent('weight-updated'));
                } else {
                    showToast('Errore nel salvataggio', 'error');
                }
            } catch (e) {
                showToast('Errore di connessione', 'error');
            } finally {
                isSaving = false;
                hero.classList.remove('stat-hero--saving');
            }
        }

        function adjustWeight(delta) {
            const weightEl = document.getElementById('heroWeight');
            if (!weightEl) return;

            if (currentWeight === null) {
                currentWeight = parseFloat(weightEl.textContent) || 70.0;
            }

            currentWeight = Math.round((currentWeight + delta) * 10) / 10;
            currentWeight = Math.max(10, Math.min(500, currentWeight));
            weightEl.textContent = currentWeight.toFixed(1);

            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => saveWeight(currentWeight), 1500);
        }

        // ============================================================
        // Long Press Detection
        // ============================================================
        const LONG_PRESS_START_DELAY = 500;   // Delay before repeat starts
        const REPEAT_INTERVAL = 150;          // Interval for repeated adjustments
        const SWITCH_TO_MEDIUM_DELAY = 2000;  // Time before switching to 0.5 kg increments
        const SWITCH_TO_LARGE_DELAY = 4000;   // Time before switching to 1.0 kg increments
        const statHero = document.getElementById('stat-hero');
        let pressTimer = null;
        let repeatInterval = null;
        let isLongPress = false;
        let pressStartTime = 0;
        let activeButton = null;
        let lastTouchTime = 0;
        let currentIncrementLevel = 'small'; // 'small' (0.1), 'medium' (0.5), 'large' (1.0)

        function handlePressStart(btn) {
            if (activeButton) return; // Prevent multiple simultaneous presses

            activeButton = btn;
            isLongPress = false;
            currentIncrementLevel = 'small';
            pressStartTime = Date.now();

            // Start long press after initial delay
            pressTimer = setTimeout(() => {
                isLongPress = true;
                const action = btn.dataset.action;

                // First adjustment with small increment
                const delta = action === 'increment' ? 0.1 : -0.1;
                adjustWeight(delta);

                // Start repeating adjustments
                repeatInterval = setInterval(() => {
                    const elapsed = Date.now() - pressStartTime;
                    let currentDelta;

                    // Determine increment level based on elapsed time
                    if (elapsed >= SWITCH_TO_LARGE_DELAY) {
                        currentIncrementLevel = 'large';
                        currentDelta = action === 'increment' ? 1.0 : -1.0;
                    } else if (elapsed >= SWITCH_TO_MEDIUM_DELAY) {
                        currentIncrementLevel = 'medium';
                        currentDelta = action === 'increment' ? 0.5 : -0.5;
                    } else {
                        currentDelta = action === 'increment' ? 0.1 : -0.1;
                    }

                    adjustWeight(currentDelta);
                }, REPEAT_INTERVAL);
            }, LONG_PRESS_START_DELAY);
        }

        function handlePressEnd(btn) {
            if (!activeButton || activeButton !== btn) return;

            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }

            if (repeatInterval) {
                clearInterval(repeatInterval);
                repeatInterval = null;
            }

            // Only trigger short press if it wasn't a long press and press was quick
            if (!isLongPress && (Date.now() - pressStartTime) < LONG_PRESS_START_DELAY) {
                const action = btn.dataset.action;
                if (action === 'increment') adjustWeight(0.1);
                else if (action === 'decrement') adjustWeight(-0.1);
            }

            isLongPress = false;
            currentIncrementLevel = 'small';
            activeButton = null;
        }

        function handlePressCancel() {
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
            if (repeatInterval) {
                clearInterval(repeatInterval);
                repeatInterval = null;
            }
            isLongPress = false;
            currentIncrementLevel = 'small';
            activeButton = null;
        }

        // Touch events for mobile
        statHero.addEventListener('touchstart', (e) => {
            const btn = e.target.closest('.stat-hero__btn');
            if (!btn) return;
            e.preventDefault();
            lastTouchTime = Date.now();
            handlePressStart(btn);
        }, { passive: false });

        statHero.addEventListener('touchmove', (e) => {
            if (activeButton) {
                e.preventDefault();
            }
        }, { passive: false });

        statHero.addEventListener('touchend', (e) => {
            if (!activeButton) return;
            e.preventDefault();
            handlePressEnd(activeButton);
        }, { passive: false });

        statHero.addEventListener('touchcancel', () => {
            handlePressCancel();
        });

        // Mouse events for desktop (skip if recent touch to prevent dual-firing)
        statHero.addEventListener('mousedown', (e) => {
            if (Date.now() - lastTouchTime < 300) return;
            const btn = e.target.closest('.stat-hero__btn');
            if (!btn) return;
            handlePressStart(btn);
        });

        statHero.addEventListener('mouseup', (e) => {
            if (!activeButton) return;
            const btn = e.target.closest('.stat-hero__btn');
            if (btn === activeButton) {
                handlePressEnd(btn);
            }
        });

        // Global mouseup to handle releases anywhere (including outside statHero)
        document.addEventListener('mouseup', () => {
            if (activeButton) {
                handlePressEnd(activeButton);
            }
        });

        // Cancel when mouse leaves the stat-hero area entirely
        statHero.addEventListener('mouseleave', () => {
            if (activeButton) handlePressCancel();
        });

        // ============================================================
        // Period Chips
        // ============================================================
        document.getElementById('periodChips').addEventListener('click', (e) => {
            const chip = e.target.closest('.period-chip');
            if (!chip) return;
            document.querySelectorAll('.period-chip').forEach(c => c.classList.remove('period-chip--active'));
            chip.classList.add('period-chip--active');
            currentPeriod = chip.dataset.period;
            renderChart();
        });

        // ============================================================
        // Pull to Refresh
        // ============================================================
        let pullStartY = 0;
        let isPulling = false;
        const pullIndicator = document.getElementById('pullIndicator');

        document.addEventListener('touchstart', (e) => {
            if (window.scrollY === 0) {
                pullStartY = e.touches[0].clientY;
                isPulling = true;
            }
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!isPulling) return;
            const pullDistance = e.touches[0].clientY - pullStartY;
            if (pullDistance > 60 && window.scrollY === 0) {
                pullIndicator.classList.add('pull-indicator--visible');
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (pullIndicator.classList.contains('pull-indicator--visible')) {
                pullIndicator.classList.add('pull-indicator--refreshing');
                document.body.dispatchEvent(new CustomEvent('weight-updated'));
                renderChart();
                setTimeout(() => {
                    pullIndicator.classList.remove('pull-indicator--visible', 'pull-indicator--refreshing');
                }, 1000);
            }
            isPulling = false;
        }, { passive: true });

        // ============================================================
        // Chart
        // ============================================================
        function itToDate(itDate) {
            const [d,m,y] = itDate.split('/');
            return new Date(y, m-1, d);
        }

        function aggregateDailyAverage(data) {
            const groups = new Map();
            for (const w of data) {
                const d = w.date;
                if (!groups.has(d)) groups.set(d, []);
                groups.get(d).push(w.value);
            }
            const dates = Array.from(groups.keys()).sort((a, b) => itToDate(a) - itToDate(b));
            return dates.map(d => {
                const vals = groups.get(d);
                return { date: d, value: vals.reduce((a,b)=>a+b,0)/vals.length };
            });
        }

        async function renderChart() {
            try {
                const [data, latest] = await Promise.all([
                    fetch(`/api/weights/${userId}?period=${currentPeriod}`).then(r=>r.json()).catch(()=>null),
                    fetch(`/api/weights/latest/${userId}`).then(r=>r.ok?r.json():null).catch(()=>null)
                ]);

                if (latest && latest.value) {
                    lastWeight = latest.value;
                }

                if (!data || !Array.isArray(data) || data.length === 0) {
                    document.querySelector('.chart__body').innerHTML = '<div class="empty-state">Nessun dato</div>';
                    return;
                }

                const averaged = aggregateDailyAverage(data);
                const labels = averaged.map(p => p.date);
                const avgValues = averaged.map(p => p.value);
                const rawPoints = data.map(w => ({ x: w.date, y: w.value, t: w.time }));

                const allWeightValues = [...avgValues, ...rawPoints.map(p => p.y)];
                if (goal) allWeightValues.push(parseFloat(goal.targetWeight));
                const minWeight = Math.min(...allWeightValues);
                const maxWeight = Math.max(...allWeightValues);
                const padding = (maxWeight - minWeight) * 0.1 || 1;
                const yMin = Math.max(0, minWeight - padding);
                const yMax = maxWeight + padding;

                const isLongPeriod = ['6months', 'year', 'all'].includes(currentPeriod);

                const colors = getChartColors();
                const config = {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                type: 'scatter',
                                label: 'Misurazioni',
                                data: isLongPeriod ? [] : rawPoints,
                                parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                                showLine: false,
                                pointRadius: 3,
                                pointHoverRadius: 5,
                                pointBorderWidth: 0,
                                pointBackgroundColor: colors.scatter
                            },
                            {
                                type: 'line',
                                label: 'Media',
                                data: avgValues,
                                borderColor: colors.line,
                                backgroundColor: colors.lineFill,
                                borderWidth: 2,
                                tension: isLongPeriod ? 0.4 : 0.3,
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                fill: true
                            },
                            {
                                type: 'line',
                                label: 'Obiettivo',
                                data: (goal && labels.length > 0) ? [{ x: labels[0], y: parseFloat(goal.targetWeight) }, { x: labels[labels.length - 1], y: parseFloat(goal.targetWeight) }] : [],
                                parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                                borderColor: colors.goal,
                                backgroundColor: 'transparent',
                                borderWidth: 1,
                                borderDash: [4, 4],
                                pointRadius: 0,
                                showLine: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'nearest', intersect: false },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: colors.tooltip,
                                titleColor: colors.tooltipText,
                                bodyColor: colors.tooltipText,
                                titleFont: { size: 11, weight: '500' },
                                bodyFont: { size: 13, weight: '600' },
                                padding: 12,
                                cornerRadius: 4,
                                displayColors: false,
                                callbacks: {
                                    title: (items) => items[0]?.label || '',
                                    label: (ctx) => {
                                        if (ctx.dataset.type === 'scatter') {
                                            const time = ctx.raw?.t || '';
                                            return time ? `${ctx.formattedValue} kg (${time})` : `${ctx.formattedValue} kg`;
                                        }
                                        return `Media: ${ctx.formattedValue} kg`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                grid: { color: colors.grid, drawBorder: false },
                                border: { display: false },
                                min: yMin,
                                max: yMax,
                                ticks: {
                                    font: { size: 11, weight: '500' },
                                    color: colors.tick,
                                    padding: 8
                                }
                            },
                            x: {
                                grid: { display: false },
                                border: { display: false },
                                ticks: {
                                    font: { size: 11, weight: '500' },
                                    color: colors.tick,
                                    maxTicksLimit: 6,
                                    padding: 8
                                }
                            }
                        }
                    }
                };

                if (chart) {
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = isLongPeriod ? [] : rawPoints;
                    chart.data.datasets[0].pointBackgroundColor = colors.scatter;
                    chart.data.datasets[1].data = avgValues;
                    chart.data.datasets[1].tension = isLongPeriod ? 0.4 : 0.3;
                    chart.data.datasets[1].borderColor = colors.line;
                    chart.data.datasets[1].backgroundColor = colors.lineFill;
                    const goalLineData = (goal && labels.length > 0) ? [{ x: labels[0], y: parseFloat(goal.targetWeight) }, { x: labels[labels.length - 1], y: parseFloat(goal.targetWeight) }] : [];
                    chart.data.datasets[2].data = goalLineData;
                    chart.data.datasets[2].borderColor = colors.goal;
                    chart.options.plugins.tooltip.backgroundColor = colors.tooltip;
                    chart.options.plugins.tooltip.titleColor = colors.tooltipText;
                    chart.options.plugins.tooltip.bodyColor = colors.tooltipText;
                    chart.options.scales.y.grid.color = colors.grid;
                    chart.options.scales.y.ticks.color = colors.tick;
                    chart.options.scales.x.ticks.color = colors.tick;
                    chart.options.scales.y.min = yMin;
                    chart.options.scales.y.max = yMax;
                    chart.update('none');
                } else {
                    chart = new Chart(ctx, config);
                }
            } catch (e) {
                console.error('Chart error:', e);
                document.querySelector('.chart__body').innerHTML = '<div class="empty-state">Errore caricamento</div>';
            }
        }

        // ============================================================
        // HTMX Event Handling
        // ============================================================
        document.body.addEventListener('htmx:afterRequest', (e) => {
            if (e.detail.successful && e.detail.verb === 'delete') {
                showToast('Peso eliminato', 'success');
            }
        });

        document.body.addEventListener('htmx:responseError', (e) => {
            showToast('Errore durante l\'operazione', 'error');
        });

        // ============================================================
        // Init
        // ============================================================
        document.addEventListener('DOMContentLoaded', renderChart);
        document.body.addEventListener('weight-updated', renderChart);

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/static/service-worker.js')
                .catch((err) => console.log('SW registration failed:', err));
        }
    </script>
</body>
</html>
