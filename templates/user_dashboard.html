<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard {{.UserID | title}}</title>
    <link rel="icon" href="/static/favicon.svg" type="image/svg+xml" />
    <link rel="stylesheet" href="/static/min.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="style-minimal">
    <header class="topbar">
        <div class="container topbar__inner">
            <a class="brand" href="/">Peso</a>
        </div>
    </header>

    <main class="container page">
        <h1 class="page__title">Dashboard {{.UserID | title}}</h1>

        <section class="page__section">
            <div id="goal-summary"
                 hx-get="/users/{{.UserID}}/goal-summary"
                 hx-trigger="load, weight-updated from:body, goal-updated from:body">
                <div class="list"><div class="row"><div class="caption">Caricamento…</div></div></div>
            </div>
        </section>

        <section class="page__section"><div id="panel"></div></section>

        <section class="page__section">
            <div class="chart">
                <div class="chart__head" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div>Andamento Peso</div>
                        <span id="goal-badge"
                              hx-get="/users/{{.UserID}}/goal-badge"
                              hx-trigger="load, weight-updated from:body, goal-updated from:body"></span>
                    </div>
                    <div>
                        <label for="periodSelect" class="caption" style="margin-right:6px;">Periodo</label>
                        <select id="periodSelect">
                            <option value="week">1 settimana</option>
                            <option value="month">1 mese</option>
                            <option value="3months" selected>3 mesi</option>
                            <option value="6months">6 mesi</option>
                            <option value="year">1 anno</option>
                            <option value="all">Tutto</option>
                        </select>
                    </div>
                </div>
                <div class="chart__body">
                    <canvas id="weightChart"></canvas>
                </div>
            </div>
        </section>

        <section class="page__section">
            <div class="actions">
                <button hx-get="/users/{{.UserID}}/weight-form" hx-target="#weight-form" class="btn btn-primary">Registra Peso</button>
            </div>
            <div id="weight-form"></div>
        </section>

        <section class="page__section">
            <div class="list" id="recent-weights"
                 hx-get="/users/{{.UserID}}/recent-weights"
                 hx-trigger="load, weight-updated from:body">
                <div class="row"><div class="caption">Caricamento…</div></div>
            </div>
        </section>
    </main>

    <script>
        console.log('Script starting...');
        let chart;
        const ctx = document.getElementById('weightChart').getContext('2d');
        const goal = {{ if .ActiveGoal }}{{ if and .CreatedAt .StartWeight }} { targetWeight: {{.ActiveGoal.TargetWeight}}, targetDate: "{{.ActiveGoal.TargetDate}}", unit: "{{.ActiveGoal.Unit}}", createdAt: "{{.CreatedAt}}", startWeight: {{.StartWeight}} }{{ else }} { targetWeight: {{.ActiveGoal.TargetWeight}}, targetDate: "{{.ActiveGoal.TargetDate}}", unit: "{{.ActiveGoal.Unit}}" }{{ end }}{{ else }} null {{ end }};
        console.log('Goal data:', goal);

        function itToDate(itDate) {
            // 'DD/MM/YYYY' -> Date object
            const [d,m,y] = itDate.split('/');
            return new Date(y, m-1, d); // month is 0-indexed in Date constructor
        }

        function aggregateDailyAverage(data) {
            const groups = new Map();
            for (const w of data) {
                const d = w.date; // already DD/MM/YYYY
                if (!groups.has(d)) groups.set(d, []);
                groups.get(d).push(w.value);
            }
            const dates = Array.from(groups.keys()).sort((a, b) => {
                // Sort DD/MM/YYYY dates chronologically
                const dateA = itToDate(a);
                const dateB = itToDate(b);
                return dateA - dateB;
            });
            const averaged = dates.map(d => {
                const vals = groups.get(d);
                const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
                return { date: d, value: avg };
            });
            return averaged;
        }

        function buildPlanPoints(goalInfo, chartLabels, averaged) {
            console.log('buildPlanPoints called with:', goalInfo);
            if (!goalInfo || !goalInfo.createdAt || goalInfo.startWeight === undefined) {
                console.log('Missing goal data, returning empty array');
                return [];
            }
            const start = itToDate(goalInfo.createdAt);
            const target = itToDate(goalInfo.targetDate);
            console.log('Dates:', {start, target});
            if (isNaN(start) || isNaN(target) || target <= start) {
                console.log('Invalid dates, returning empty array');
                return [];
            }
            
            const targetWeight = parseFloat(goalInfo.targetWeight);
            const startWeight = goalInfo.startWeight;
            
            if (chartLabels.length === 0) {
                return [];
            }
            
            let points = [];
            const firstChartDate = itToDate(chartLabels[0]);
            const lastChartDate = itToDate(chartLabels[chartLabels.length - 1]);
            
            // Calculate the theoretical line from goal creation to target
            const totalDays = (target - start) / (1000 * 60 * 60 * 24);
            
            // Start point: either at goal creation date or at chart boundary
            if (start >= firstChartDate && start <= lastChartDate) {
                // Goal creation is within chart range, start from there
                points.push({ x: goalInfo.createdAt, y: startWeight });
            } else if (start < firstChartDate) {
                // Goal creation is before chart, calculate weight at first chart date
                const daysToFirstChart = (firstChartDate - start) / (1000 * 60 * 60 * 24);
                const weightAtFirstChart = startWeight + ((targetWeight - startWeight) * daysToFirstChart / totalDays);
                points.push({ x: chartLabels[0], y: weightAtFirstChart });
            }
            
            // End point: only add if target date is within reasonable chart range
            if (target <= lastChartDate || (target - lastChartDate) / (1000 * 60 * 60 * 24) <= 30) {
                // Target is within chart or max 30 days after last data point
                points.push({ x: goalInfo.targetDate, y: targetWeight });
            } else {
                // Target is too far, extend line to last chart date
                const daysToLastChart = (lastChartDate - start) / (1000 * 60 * 60 * 24);
                const weightAtLastChart = startWeight + ((targetWeight - startWeight) * daysToLastChart / totalDays);
                points.push({ x: chartLabels[chartLabels.length - 1], y: weightAtLastChart });
            }
            
            console.log('Plan points:', points);
            return points;
        }

        function todayIt() {
            const d = new Date();
            const day = String(d.getDate()).padStart(2,'0');
            const m = String(d.getMonth()+1).padStart(2,'0');
            const y = d.getFullYear();
            return `${day}/${m}/${y}`;
        }

        async function renderChart() {
            try {
                const periodEl = document.getElementById('periodSelect');
                const period = periodEl ? periodEl.value : '3months';
                const [data, latest] = await Promise.all([
                    fetch(`/api/weights/{{.UserID}}?period=${period}`).then(r=>r.json()),
                    fetch(`/api/weights/latest/{{.UserID}}`).then(r=>r.ok?r.json():null).catch(()=>null)
                ]);
                const averaged = aggregateDailyAverage(data);
                const labels = averaged.map(p => p.date);
                const avgValues = averaged.map(p => p.value);
                const rawPoints = data.map(w => ({ x: w.date, y: w.value, t: w.time }));

                // Calculate Y axis limits based only on weight data (exclude goal line)
                const allWeightValues = [...avgValues, ...rawPoints.map(p => p.y)];
                const minWeight = Math.min(...allWeightValues);
                const maxWeight = Math.max(...allWeightValues);
                const padding = (maxWeight - minWeight) * 0.1 || 1; // 10% padding or minimum 1kg
                const yMin = Math.max(0, minWeight - padding);
                const yMax = maxWeight + padding;

                // trajectory from goal creation date towards target using starting weight
                const planPoints = goal ? buildPlanPoints(goal, labels, averaged) : [];
                console.log('Plan points for chart:', planPoints);

                const config = {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                type: 'scatter',
                                label: 'Misurazioni',
                                data: rawPoints,
                                parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                                showLine: false,
                                pointRadius: 3,
                                pointHoverRadius: 4,
                                pointBorderWidth: 0,
                                pointBackgroundColor: 'rgb(17, 17, 17)'
                            },
                            {
                                type: 'line',
                                label: 'Media giornaliera',
                                data: avgValues,
                                borderColor: 'rgb(17, 17, 17)',
                                backgroundColor: 'rgba(17, 17, 17, 0.05)',
                                tension: 0.2,
                                pointRadius: 5,
                                pointHoverRadius: 6,
                                pointBorderWidth: 2,
                                pointBackgroundColor: '#fff',
                                pointBorderColor: 'rgb(17, 17, 17)'
                            },
                            {
                                type: 'line',
                                label: 'Traiettoria ideale',
                                data: planPoints,
                                parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                                borderColor: 'rgba(0,0,0,0.2)',
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                showLine: true,
                                xAxisID: 'x',
                                yAxisID: 'y'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: (items) => items[0]?.label || '',
                                    label: (ctx) => {
                                        if (ctx.dataset.type === 'scatter') {
                                            const time = ctx.raw && ctx.raw.t ? ctx.raw.t : '';
                                            return time ? `Ora ${time} · ${ctx.formattedValue} kg` : `${ctx.formattedValue} kg`;
                                        }
                                        return `Media ${ctx.formattedValue} kg`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { 
                                beginAtZero: false, 
                                grid: { color: 'rgba(0,0,0,0.06)' },
                                min: yMin,
                                max: yMax
                            },
                            x: { grid: { display: false } }
                        }
                    }
                };

                if (chart) {
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = rawPoints;
                    chart.data.datasets[1].data = avgValues;
                    if (chart.data.datasets[2]) {
                        chart.data.datasets[2].data = planPoints;
                    } else {
                        chart.data.datasets.push({
                            type: 'line',
                            label: 'Traiettoria ideale',
                            data: planPoints,
                            parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                            borderColor: 'rgba(0,0,0,0.2)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            showLine: true,
                            xAxisID: 'x',
                            yAxisID: 'y'
                        });
                    }
                    chart.options.scales.y.min = yMin;
                    chart.options.scales.y.max = yMax;
                    chart.update();
                } else {
                    chart = new Chart(ctx, config);
                }
            } catch (e) {
                console.error('Error loading chart data:', e);
                const body = document.querySelector('.chart__body');
                if (body) body.innerHTML = '<div class="caption">Errore nel caricamento del grafico</div>';
            }
        }

        document.addEventListener('DOMContentLoaded', renderChart);
        document.body.addEventListener('weight-updated', renderChart);
        document.addEventListener('change', (e) => {
            if (e.target && e.target.id === 'periodSelect') {
                renderChart();
            }
        });
    </script>
</body>
</html>
