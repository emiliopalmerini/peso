<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard {{.UserID | title}}</title>
    <link rel="stylesheet" href="/static/min.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="style-minimal">
    <header class="topbar">
        <div class="container topbar__inner">
            <a class="brand" href="/">Peso</a>
        </div>
    </header>

    <main class="container page">
        <h1 class="page__title">Dashboard {{.UserID | title}}</h1>

        <section class="page__section">
            <div id="goal-summary"
                 hx-get="/users/{{.UserID}}/goal-summary"
                 hx-trigger="load, weight-updated from:body, goal-updated from:body">
                <div class="list"><div class="row"><div class="caption">Caricamento…</div></div></div>
            </div>
        </section>

        <section class="page__section"><div id="panel"></div></section>

        <section class="page__section">
            <div class="chart">
                <div class="chart__head" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div>Andamento Peso</div>
                        <span id="goal-badge"
                              hx-get="/users/{{.UserID}}/goal-badge"
                              hx-trigger="load, weight-updated from:body, goal-updated from:body"></span>
                    </div>
                    <div>
                        <label for="periodSelect" class="caption" style="margin-right:6px;">Periodo</label>
                        <select id="periodSelect">
                            <option value="week">1 settimana</option>
                            <option value="month">1 mese</option>
                            <option value="3months" selected>3 mesi</option>
                            <option value="6months">6 mesi</option>
                            <option value="year">1 anno</option>
                            <option value="all">Tutto</option>
                        </select>
                    </div>
                </div>
                <div class="chart__body">
                    <canvas id="weightChart"></canvas>
                </div>
            </div>
        </section>

        <section class="page__section">
            <div class="actions">
                <button hx-get="/users/{{.UserID}}/weight-form" hx-target="#weight-form" class="btn btn-primary">Registra Peso</button>
            </div>
            <div id="weight-form"></div>
        </section>

        <section class="page__section">
            <div class="list" id="recent-weights"
                 hx-get="/users/{{.UserID}}/recent-weights"
                 hx-trigger="load, weight-updated from:body">
                <div class="row"><div class="caption">Caricamento…</div></div>
            </div>
        </section>
    </main>

    <script>
        let chart;
        const ctx = document.getElementById('weightChart').getContext('2d');
        const goal = {{ if .ActiveGoal }} { targetWeight: {{.ActiveGoal.TargetWeight}}, targetDate: "{{.ActiveGoal.TargetDate}}", unit: "{{.ActiveGoal.Unit}}" } {{ else }} null {{ end }};

        function isoToIt(iso) {
            // iso 'YYYY-MM-DD' -> 'DD/MM/YYYY'
            const [y,m,d] = iso.split('-');
            return `${d}/${m}/${y}`;
        }

        function aggregateDailyAverage(data) {
            const groups = new Map();
            for (const w of data) {
                const d = w.date; // already YYYY-MM-DD
                if (!groups.has(d)) groups.set(d, []);
                groups.get(d).push(w.value);
            }
            const dates = Array.from(groups.keys()).sort();
            const averaged = dates.map(d => {
                const vals = groups.get(d);
                const avg = vals.reduce((a,b)=>a+b,0)/vals.length;
                return { iso: d, date: isoToIt(d), value: avg };
            });
            return averaged;
        }

        function buildPlanValues(labelsIso, latestIso, latestValue, goalInfo) {
            if (!goalInfo || !latestIso) return Array(labelsIso.length).fill(null);
            const start = new Date(latestIso);
            const target = new Date(goalInfo.targetDate);
            if (isNaN(start) || isNaN(target) || target <= start) {
                return Array(labelsIso.length).fill(null);
            }
            const totalDays = Math.round((target - start) / 86400000);
            if (totalDays <= 0) return Array(labelsIso.length).fill(null);
            const delta = (goalInfo.targetWeight - latestValue) / totalDays;
            return labelsIso.map(iso => {
                const d = new Date(iso);
                if (d < start || d > target) return null;
                const daysFromStart = Math.round((d - start) / 86400000);
                return +(latestValue + delta * daysFromStart).toFixed(1);
            });
        }

        function isoToday() {
            const d = new Date();
            const y = d.getFullYear();
            const m = String(d.getMonth()+1).padStart(2,'0');
            const day = String(d.getDate()).padStart(2,'0');
            return `${y}-${m}-${day}`;
        }

        async function renderChart() {
            try {
                const periodEl = document.getElementById('periodSelect');
                const period = periodEl ? periodEl.value : '3months';
                const [data, latest] = await Promise.all([
                    fetch(`/api/weights/{{.UserID}}?period=${period}`).then(r=>r.json()),
                    fetch(`/api/weights/latest/{{.UserID}}`).then(r=>r.ok?r.json():null).catch(()=>null)
                ]);
                const averaged = aggregateDailyAverage(data);
                const labels = averaged.map(p => p.date);
                const labelsIso = averaged.map(p => p.iso);
                const avgValues = averaged.map(p => p.value);
                const rawPoints = data.map(w => ({ x: isoToIt(w.date), y: w.value, t: w.time }));

                // trajectory from today towards target using latest known value
                const latestValue = latest && latest.value != null ? latest.value : (data.length ? data[data.length-1].value : null);
                const latestIso = isoToday();
                const planValues = (goal && latestValue != null) ? buildPlanValues(labelsIso, latestIso, latestValue, goal) : Array(labels.length).fill(null);

                const config = {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                type: 'scatter',
                                label: 'Misurazioni',
                                data: rawPoints,
                                parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                                showLine: false,
                                pointRadius: 3,
                                pointHoverRadius: 4,
                                pointBorderWidth: 0,
                                pointBackgroundColor: 'rgb(17, 17, 17)'
                            },
                            {
                                type: 'line',
                                label: 'Media giornaliera',
                                data: avgValues,
                                borderColor: 'rgb(17, 17, 17)',
                                backgroundColor: 'rgba(17, 17, 17, 0.05)',
                                tension: 0.2,
                                pointRadius: 5,
                                pointHoverRadius: 6,
                                pointBorderWidth: 2,
                                pointBackgroundColor: '#fff',
                                pointBorderColor: 'rgb(17, 17, 17)'
                            },
                            {
                                type: 'line',
                                label: 'Traiettoria obiettivo',
                                data: planValues,
                                borderColor: 'rgba(0,0,0,0.35)',
                                backgroundColor: 'transparent',
                                borderWidth: 1,
                                borderDash: [6, 6],
                                pointRadius: 0,
                                spanGaps: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: (items) => items[0]?.label || '',
                                    label: (ctx) => {
                                        if (ctx.dataset.type === 'scatter') {
                                            const time = ctx.raw && ctx.raw.t ? ctx.raw.t : '';
                                            return time ? `Ora ${time} · ${ctx.formattedValue} kg` : `${ctx.formattedValue} kg`;
                                        }
                                        return `Media ${ctx.formattedValue} kg`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { beginAtZero: false, grid: { color: 'rgba(0,0,0,0.06)' } },
                            x: { grid: { display: false } }
                        }
                    }
                };

                if (chart) {
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = rawPoints;
                    chart.data.datasets[1].data = avgValues;
                    if (chart.data.datasets[2]) {
                        chart.data.datasets[2].data = planValues;
                    } else {
                        chart.data.datasets.push({
                            type: 'line',
                            label: 'Traiettoria obiettivo',
                            data: planValues,
                            borderColor: 'rgba(0,0,0,0.35)',
                            backgroundColor: 'transparent',
                            borderWidth: 1,
                            borderDash: [6, 6],
                            pointRadius: 0,
                            spanGaps: true
                        });
                    }
                    chart.update();
                } else {
                    chart = new Chart(ctx, config);
                }
            } catch (e) {
                console.error('Error loading chart data:', e);
                const body = document.querySelector('.chart__body');
                if (body) body.innerHTML = '<div class="caption">Errore nel caricamento del grafico</div>';
            }
        }

        document.addEventListener('DOMContentLoaded', renderChart);
        document.body.addEventListener('weight-updated', renderChart);
        document.addEventListener('change', (e) => {
            if (e.target && e.target.id === 'periodSelect') {
                renderChart();
            }
        });
    </script>
</body>
</html>
